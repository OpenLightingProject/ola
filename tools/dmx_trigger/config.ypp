%{
#include <ola/Logging.h>
#include "ConfigCommon.h"
#include "ParserActions.h"
int yyerror(const char *s);
int yylex(void);

%}

%union{
  unsigned int int_val;
  std::string *str_val;
  std::vector<std::string> *str_list;
  class Action *action;
  IntervalList *interval_list;
  ValueInterval *interval;
}

%start  config

%token NEW_LINE
%token WHITESPACE
%token <int_val> INTEGER_LITERAL
%token <str_val> QUOTED_VALUE
%token <str_val> WORD_LITERAL
%type <str_val> value
%type <str_val> program
%type <str_val> full_path
%type <str_list> arguments
%type <str_val> argument
%type <str_list> assignment
%type <action> action;
%type <interval_list> slot_values;
%type <interval> slot_value_range;

%%
config :
      /* empty */
    | config line
;

line :
      NEW_LINE
    | expression optional_whitespace NEW_LINE
;

expression :
      assignment { SetDefaultValue($1); }
    | slot_action
;

assignment :
      WORD_LITERAL optional_whitespace '=' optional_whitespace value {
        $$ = new vector<string>;
        $$->push_back(*$1);
        $$->push_back(*$5);
        delete $1;
        delete $5;
      }
;

value :
      WORD_LITERAL
    | QUOTED_VALUE
;

optional_whitespace:
     /* empty */
    | WHITESPACE
;

slot_action:
      INTEGER_LITERAL WHITESPACE slot_values WHITESPACE action {
        SetSlotAction($1, $3, $5);
      }
    | INTEGER_LITERAL WHITESPACE '%' WHITESPACE action {
        SetDefaultAction($1, $5);
      }
;

slot_values:
      slot_value_range { $$ = new IntervalList(); $$->push_back($1); }
    | slot_values ',' slot_value_range { $$ = $1; $$->push_back($3); }
;

slot_value_range:
      INTEGER_LITERAL { $$ = new ValueInterval($1, $1); }
    | INTEGER_LITERAL '-' INTEGER_LITERAL { $$ = new ValueInterval($1, $3); }
;

action:
      assignment { $$ = CreateAssignmentAction($1); }
    | '`' program arguments '`' {
        $$ = CreateCommandAction(*$2, $3);
        delete $2;
      }
;

arguments:
      /* empty */ { $$ = new vector<string>(); }
    | arguments WHITESPACE argument {
        $$ = $1; $$->push_back(string(*$3));
        delete $3;
    }
;

argument:
      WORD_LITERAL
    | QUOTED_VALUE
;

program:
      WORD_LITERAL
    | full_path
;

full_path:
    '/' WORD_LITERAL { $$ = new string("/"); $$->append(*$2); }
    | full_path '/' WORD_LITERAL  {
        $$ = new string(*$1);
        $$->append("/");
        $$->append(*$3);
        delete $1;
        delete $3;
      }
;

%%
extern int column;

int yyerror(string s) {
  extern int yylineno;  // defined and maintained in lex.c
  extern char *yytext;  // defined and maintained in lex.c

  OLA_FATAL << "ERROR: " << s << " at symbol \"" << yytext;
  OLA_FATAL << "\" on line " << yylineno << " column " << column;
  exit(1);
}

int yyerror(const char *s) {
  return yyerror(string(s));
}
